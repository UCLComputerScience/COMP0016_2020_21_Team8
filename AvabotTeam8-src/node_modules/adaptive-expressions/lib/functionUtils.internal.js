"use strict";
/**
 * @module adaptive-expressions
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const moment_1 = __importDefault(require("moment"));
const expressionType_1 = require("./expressionType");
const memory_1 = require("./memory");
const recognizers_text_data_types_timex_expression_1 = require("@microsoft/recognizers-text-data-types-timex-expression");
const bigInt = require("big-integer");
/**
 * Utility functions only used internal
 */
class InternalFunctionUtils {
    /**
     * Parse timex funcition.
     * @param timexExpr String or TimexProperty input.
     * @returns TimexProperty and error.
     */
    static parseTimexProperty(timexExpr) {
        let parsed;
        if (timexExpr instanceof recognizers_text_data_types_timex_expression_1.TimexProperty) {
            parsed = timexExpr;
        }
        else if (typeof timexExpr === 'string') {
            parsed = new recognizers_text_data_types_timex_expression_1.TimexProperty(timexExpr);
        }
        else {
            parsed = new recognizers_text_data_types_timex_expression_1.TimexProperty(timexExpr);
            if (parsed === undefined || Object.keys(parsed).length === 0) {
                return {
                    timexProperty: parsed,
                    error: `${timexExpr} requires a TimexProperty or a string as a argument`,
                };
            }
        }
        return { timexProperty: parsed, error: undefined };
    }
    /**
     * Convert string into Uint8Array object.
     * @param stringToConvert Input string.
     */
    static toBinary(stringToConvert) {
        const result = new ArrayBuffer(stringToConvert.length);
        const bufferView = new Uint8Array(result);
        for (let i = 0; i < stringToConvert.length; i++) {
            bufferView[i] = stringToConvert.charCodeAt(i);
        }
        return bufferView;
    }
    /**
     * Sort helper function.
     * @param isDescending Descending flag.
     */
    static sortBy(isDescending) {
        return (expression, state, options) => {
            let result;
            const { value: oriArr, error: childrenError } = expression.children[0].tryEvaluate(state, options);
            let error = childrenError;
            if (!error) {
                if (Array.isArray(oriArr)) {
                    const arr = oriArr.slice(0);
                    if (expression.children.length === 1) {
                        if (isDescending) {
                            result = arr.sort().reverse();
                        }
                        else {
                            result = arr.sort();
                        }
                    }
                    else {
                        let propertyName;
                        ({ value: propertyName, error } = expression.children[1].tryEvaluate(state, options));
                        if (!error) {
                            propertyName = propertyName || '';
                        }
                        if (isDescending) {
                            result = sortBy_1.default(arr, propertyName).reverse();
                        }
                        else {
                            result = sortBy_1.default(arr, propertyName);
                        }
                    }
                }
                else {
                    error = `${expression.children[0]} is not an array`;
                }
            }
            return { value: result, error };
        };
    }
    /**
     * Lookup a string or number index of an Object.
     * @param instance Instance with property.
     * @param property Property to lookup.
     * @returns Value and error information if any.
     */
    static accessIndex(instance, index) {
        // NOTE: This returns undefined rather than an error if property is not present
        if (instance === null || instance === undefined) {
            return { value: undefined, error: undefined };
        }
        let value;
        let error;
        if (Array.isArray(instance)) {
            if (index >= 0 && index < instance.length) {
                value = instance[index];
            }
            else {
                error = `${index} is out of range for ${instance}`;
            }
        }
        else {
            error = `${instance} is not a collection.`;
        }
        return { value, error };
    }
    /**
     * Verify a timestamp string is valid timestamp format.
     * @param value Timestamp string to check.
     * @returns Error or undefined if invalid.
     */
    static verifyTimestamp(value) {
        let error;
        try {
            const parsedData = new Date(value);
            if (Number.isNaN(parsedData.getTime())) {
                error = `${value} is not a valid datetime string.`;
            }
        }
        catch (e) {
            error = `${value} is not a valid datetime string.`;
        }
        return error;
    }
    /**
     * Verify a timestamp string is valid ISO timestamp format.
     * @param value Timestamp string to check.
     * @returns Error or undefined if invalid.
     */
    static verifyISOTimestamp(value) {
        let error;
        try {
            const parsedData = new Date(value);
            if (Number.isNaN(parsedData.getTime())) {
                error = `${value} is not a valid datetime string.`;
            }
            else if (parsedData.toISOString() !== value) {
                error = `${value} is not a ISO format datetime string.`;
            }
        }
        catch (e) {
            error = `${value} is not a valid datetime string.`;
        }
        return error;
    }
    /**
     * Transform a timestamp into another with customized function.
     * @param timeStamp Original time stamp.
     * @param transform Transform function.
     * @returns New timestamp and error.
     */
    static parseTimestamp(timeStamp, transform) {
        let value;
        const error = this.verifyISOTimestamp(timeStamp);
        if (!error) {
            value = transform !== undefined ? transform(new Date(timeStamp)) : timeStamp;
        }
        return { value, error };
    }
    /**
     * Convert a string input to ticks number.
     * @param timeStamp String timestamp input.
     */
    static ticks(timeStamp) {
        let result;
        const { value: parsed, error } = this.parseTimestamp(timeStamp);
        if (!error) {
            const unixMilliSec = parseInt(moment_1.default(parsed).utc().format('x'), 10);
            result = this.UnixMilliSecondToTicksConstant.add(bigInt(unixMilliSec).times(this.MillisecondToTickConstant));
        }
        return { value: result, error };
    }
    /**
     * Lookup a property in Map or Object.
     * @param instance Instance with property.
     * @param property Property to lookup.
     * @returns Value and error information if any.
     */
    static accessProperty(instance, property) {
        // NOTE: This returns undefined rather than an error if property is not present
        if (!instance) {
            return { value: undefined, error: undefined };
        }
        let value;
        let error;
        if (instance instanceof Map && instance !== undefined) {
            const instanceMap = instance;
            value = instanceMap.get(property);
            if (value === undefined) {
                const prop = Array.from(instanceMap.keys()).find((k) => k.toLowerCase() === property.toLowerCase());
                if (prop !== undefined) {
                    value = instanceMap.get(prop);
                }
            }
        }
        else {
            const prop = Object.keys(instance).find((k) => k.toLowerCase() === property.toLowerCase());
            if (prop !== undefined) {
                value = instance[prop];
            }
        }
        return { value, error };
    }
    /**
     * Get the value of a path from a memory
     * @param state Memory.
     * @param path Path string.
     * @param options Options.
     */
    static wrapGetValue(state, path, options) {
        const result = state.getValue(path);
        if (result !== undefined && result !== null) {
            return result;
        }
        if (options.nullSubstitution !== undefined) {
            return options.nullSubstitution(path);
        }
        return undefined;
    }
    /**
     * Wrap string or undefined into string. Default to empty string.
     * @param input Input string
     */
    static parseStringOrUndefined(input) {
        if (typeof input === 'string') {
            return input;
        }
        else {
            return '';
        }
    }
    /**
     * Test result to see if True in logical comparison functions.
     * @param instance Computed value.
     * @returns True if boolean true or non-null.
     */
    static isLogicTrue(instance) {
        let result = true;
        if (typeof instance === 'boolean') {
            result = instance;
        }
        else if (instance === undefined || instance === null) {
            result = false;
        }
        return result;
    }
    /**
     * Evaluator for foreach and select functions.
     * @param expression Expression.
     * @param state Memory scope.
     * @param options Options.
     */
    static foreach(expression, state, options) {
        let result;
        const { value: instance, error: childrenError } = expression.children[0].tryEvaluate(state, options);
        let error = childrenError;
        if (!instance) {
            error = `'${expression.children[0]}' evaluated to null.`;
        }
        if (!error) {
            const iteratorName = expression.children[1].children[0].value;
            let arr = [];
            if (Array.isArray(instance)) {
                arr = instance;
            }
            else if (typeof instance === 'object') {
                Object.keys(instance).forEach((u) => arr.push({ key: u, value: instance[u] }));
            }
            else {
                error = `${expression.children[0]} is not a collection or structure object to run foreach`;
            }
            if (!error) {
                const stackedMemory = memory_1.StackedMemory.wrap(state);
                result = [];
                for (const item of arr) {
                    const local = new Map([[iteratorName, item]]);
                    stackedMemory.push(memory_1.SimpleObjectMemory.wrap(local));
                    const { value: r, error: e } = expression.children[2].tryEvaluate(stackedMemory, options);
                    stackedMemory.pop();
                    if (e !== undefined) {
                        return { value: undefined, error: e };
                    }
                    result.push(r);
                }
            }
        }
        return { value: result, error };
    }
    /**
     * Validator for foreach, select, and where functions.
     * @param expression
     */
    static validateForeach(expression) {
        if (expression.children.length !== 3) {
            throw new Error(`foreach expect 3 parameters, found ${expression.children.length}`);
        }
        const second = expression.children[1];
        if (!(second.type === expressionType_1.ExpressionType.Accessor && second.children.length === 1)) {
            throw new Error(`Second parameter of foreach is not an identifier : ${second}`);
        }
    }
    /**
     * Parse string into URL object.
     * @param uri Input string uri.
     */
    static parseUri(uri) {
        let result;
        let error;
        try {
            result = new URL(uri);
        }
        catch (e) {
            error = `Invalid URI: ${uri}`;
        }
        return { value: result, error };
    }
    /**
     * Transform C# period and unit into js period and unit
     * @param duration C# duration
     * @param cSharpStr C# unit.
     */
    static timeUnitTransformer(duration, cSharpStr) {
        switch (cSharpStr) {
            case 'Day':
                return { duration, tsStr: 'days' };
            case 'Week':
                return { duration: duration * 7, tsStr: 'days' };
            case 'Second':
                return { duration, tsStr: 'seconds' };
            case 'Minute':
                return { duration, tsStr: 'minutes' };
            case 'Hour':
                return { duration, tsStr: 'hours' };
            case 'Month':
                return { duration, tsStr: 'months' };
            case 'Year':
                return { duration, tsStr: 'years' };
            default:
                return { duration, tsStr: undefined };
        }
    }
    /**
     * Format datetime.
     * @param timedata Input date time.
     * @param format Format flag.
     */
    static returnFormattedTimeStampStr(timedata, format) {
        let result;
        let error;
        try {
            result = timedata.format(format);
        }
        catch (e) {
            error = `${format} is not a valid timestamp format`;
        }
        return { value: result, error };
    }
    /**
     * Equal helper function.
     * @param args Input args. Compare the first param and second param.
     */
    static isEqual(args) {
        if (args.length === 0) {
            return false;
        }
        if (args[0] === undefined || args[0] === null || args[1] === undefined || args[1] === null) {
            return (args[0] === undefined || args[0] === null) && (args[1] === undefined || args[1] === null);
        }
        if (Array.isArray(args[0]) && args[0].length === 0 && Array.isArray(args[1]) && args[1].length === 0) {
            return true;
        }
        if (InternalFunctionUtils.getPropertyCount(args[0]) === 0 &&
            InternalFunctionUtils.getPropertyCount(args[1]) === 0) {
            return true;
        }
        try {
            return args[0] === args[1];
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Helper function of get the number of properties of an object.
     * @param obj An object.
     */
    static getPropertyCount(obj) {
        let count = -1;
        if (!Array.isArray(obj)) {
            if (obj instanceof Map) {
                count = obj.size;
            }
            else if (typeof obj === 'object') {
                count = Object.keys(obj).length;
            }
        }
        return count;
    }
}
/**
 * Constant for converting unix timestamp to ticks.
 */
InternalFunctionUtils.UnixMilliSecondToTicksConstant = bigInt('621355968000000000');
/**
 * Constant to convert between ticks and ms.
 */
InternalFunctionUtils.MillisecondToTickConstant = bigInt('10000');
exports.InternalFunctionUtils = InternalFunctionUtils;
//# sourceMappingURL=functionUtils.internal.js.map