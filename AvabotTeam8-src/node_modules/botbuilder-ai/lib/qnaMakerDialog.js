"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_core_1 = require("botbuilder-core");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const rankerTypes_1 = require("./qnamaker-interfaces/rankerTypes");
const joinOperator_1 = require("./qnamaker-interfaces/joinOperator");
const _1 = require("./");
const qnaCardBuilder_1 = require("./qnaCardBuilder");
const bindToActivity_1 = require("./qnamaker-utils/bindToActivity");
const activeLearningUtils_1 = require("./qnamaker-utils/activeLearningUtils");
class QnAMakerDialogActivityConverter {
    convert(value) {
        if (typeof value === 'string') {
            return new bindToActivity_1.BindToActivity(botbuilder_core_1.MessageFactory.text(value));
        }
        return value;
    }
}
/**
 * A dialog that supports multi-step and adaptive-learning QnA Maker services.
 *
 * @remarks
 * An instance of this class targets a specific QnA Maker knowledge base.
 * It supports knowledge bases that include follow-up prompt and active learning features.
 * The dialog will also present user with appropriate multi-turn prompt or active learning options.
 */
class QnAMakerDialog extends botbuilder_dialogs_1.WaterfallDialog {
    /**
     * Initializes a new instance of the [QnAMakerDialog](xref:QnAMakerDialog) class.
     * @param knowledgeBaseId The ID of the QnA Maker knowledge base to query.
     * @param endpointKey The QnA Maker endpoint key to use to query the knowledge base.
     * @param hostName The QnA Maker host URL for the knowledge base, starting with "https://" and ending with "/qnamaker".
     * @param noAnswer (Optional) The activity to send the user when QnA Maker does not find an answer.
     * @param threshold (Optional) The threshold above which to treat answers found from the knowledgebase as a match.
     * @param activeLearningCardTitle (Optional) The card title to use when showing active learning options to the user, if active learning is enabled.
     * @param cardNoMatchText (Optional) The button text to use with active learning options, allowing a user to indicate none of the options are applicable.
     * @param top (Optional) Maximum number of answers to return from the knowledge base.
     * @param cardNoMatchResponse (Optional) The activity to send the user if they select the no match option on an active learning card.
     * @param strictFilters (Optional) QnA Maker metadata with which to filter or boost queries to the knowledge base; or null to apply none.
     * @param dialogId (Optional) Id of the created dialog. Default is 'QnAMakerDialog'.
     */
    constructor(knowledgeBaseId, endpointKey, hostname, noAnswer, threshold = 0.3, activeLearningCardTitle = 'Did you mean:', cardNoMatchText = 'None of the above.', top = 3, cardNoMatchResponse, strictFilters, dialogId = 'QnAMakerDialog', strictFiltersJoinOperator = joinOperator_1.JoinOperator.AND) {
        super(dialogId);
        /**
         * Log personal information flag.
         *
         * @remarks
         * Defauls to a value of `=settings.logPersonalInformation`, which retrieves
         * `logPersonalInformation` flag from settings.
         */
        this.logPersonalInformation = new adaptive_expressions_1.BoolExpression('=settings.logPersonalInformation');
        // state and step value key constants
        /**
         * The path for storing and retrieving QnA Maker context data.
         *
         * @remarks
         * This represents context about the current or previous call to QnA Maker.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.qnAContextData = 'previousContextData';
        /**
         * The path for storing and retrieving the previous question ID.
         *
         * @remarks
         * This represents the QnA question ID from the previous turn.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker's follow-up prompt and active learning features.
         */
        this.previousQnAId = 'previousQnAId';
        /**
         * The path for storing and retrieving the options for this instance of the dialog.
         *
         * @remarks
         * This includes the options with which the dialog was started and options expected by the QnA Maker service.
         * It is stored within the current step's [WaterfallStepContext](xref:botbuilder-dialogs.WaterfallStepContext).
         * It supports QnA Maker and the dialog system.
         */
        this.options = 'options';
        this.qnAData = 'qnaData';
        this.currentQuery = 'currentQuery';
        // Dialog options parameters
        this.defaultCardNoMatchResponse = `Thanks for the feedback.`;
        this.defaultNoAnswer = `No QnAMaker answers found.`;
        this.threshold = new adaptive_expressions_1.NumberExpression(0.3);
        this.top = new adaptive_expressions_1.IntExpression(3);
        this.noAnswer = new bindToActivity_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultNoAnswer));
        this.cardNoMatchResponse = new bindToActivity_1.BindToActivity(botbuilder_core_1.MessageFactory.text(this.defaultCardNoMatchResponse));
        this.isTest = false;
        this.rankerType = new adaptive_expressions_1.EnumExpression(rankerTypes_1.RankerTypes.default);
        if (knowledgeBaseId) {
            this.knowledgeBaseId = new adaptive_expressions_1.StringExpression(knowledgeBaseId);
        }
        if (endpointKey) {
            this.endpointKey = new adaptive_expressions_1.StringExpression(endpointKey);
        }
        if (hostname) {
            this.hostname = new adaptive_expressions_1.StringExpression(hostname);
        }
        if (threshold) {
            this.threshold = new adaptive_expressions_1.NumberExpression(threshold);
        }
        if (top) {
            this.top = new adaptive_expressions_1.IntExpression(top);
        }
        if (activeLearningCardTitle) {
            this.activeLearningCardTitle = new adaptive_expressions_1.StringExpression(activeLearningCardTitle);
        }
        if (cardNoMatchText) {
            this.cardNoMatchText = new adaptive_expressions_1.StringExpression(cardNoMatchText);
        }
        if (strictFilters) {
            this.strictFilters = new adaptive_expressions_1.ArrayExpression(strictFilters);
        }
        if (noAnswer) {
            this.noAnswer = new bindToActivity_1.BindToActivity(noAnswer);
        }
        if (cardNoMatchResponse) {
            this.cardNoMatchResponse = new bindToActivity_1.BindToActivity(cardNoMatchResponse);
        }
        this.strictFiltersJoinOperator = strictFiltersJoinOperator;
        this.addStep(this.callGenerateAnswer.bind(this));
        this.addStep(this.callTrain.bind(this));
        this.addStep(this.checkForMultiTurnPrompt.bind(this));
        this.addStep(this.displayQnAResult.bind(this));
    }
    getConverter(property) {
        switch (property) {
            case 'knowledgeBaseId':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'hostname':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'endpointKey':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'threshold':
                return new adaptive_expressions_1.NumberExpressionConverter();
            case 'top':
                return new adaptive_expressions_1.IntExpressionConverter();
            case 'noAnswer':
                return new QnAMakerDialogActivityConverter();
            case 'activeLearningCardTitle':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchText':
                return new adaptive_expressions_1.StringExpressionConverter();
            case 'cardNoMatchResponse':
                return new QnAMakerDialogActivityConverter();
            case 'strictFilters':
                return new adaptive_expressions_1.ArrayExpressionConverter();
            case 'logPersonalInformation':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'rankerType':
                return new adaptive_expressions_1.EnumExpressionConverter(rankerTypes_1.RankerTypes);
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Called when the dialog is started and pushed onto the dialog stack.
     *
     * @remarks
     * If the task is successful, the result indicates whether the dialog is still
     * active after the turn has been processed by the dialog.
     *
     * You can use the [options](#options) parameter to include the QnA Maker context data,
     * which represents context from the previous query. To do so, the value should include a
     * `context` property of type [QnAResponseContext](#QnAResponseContext).
     *
     * @param dc The [DialogContext](xref:botbuilder-dialogs.DialogContext) for the current turn of conversation.
     * @param options (Optional) Initial information to pass to the dialog.
     */
    beginDialog(dc, options) {
        const _super = Object.create(null, {
            beginDialog: { get: () => super.beginDialog }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (!dc) {
                throw new Error('Missing DialogContext');
            }
            if (dc.context.activity.type != botbuilder_core_1.ActivityTypes.Message) {
                return dc.endDialog();
            }
            const dialogOptions = {
                qnaDialogResponseOptions: yield this.getQnAResponseOptions(dc),
                qnaMakerOptions: yield this.getQnAMakerOptions(dc),
            };
            if (options) {
                Object.assign(dialogOptions, options);
            }
            return yield _super.beginDialog.call(this, dc, dialogOptions);
        });
    }
    /**
     * Gets the options for the QnA Maker client that the dialog will use to query the knowledge base.
     * @param dc The dialog context for the current turn of conversation.
     * @remarks If the task is successful, the result contains the QnA Maker options to use.
     * @returns A new instance of QnAMakerOptions.
     */
    getQnAMakerOptions(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                scoreThreshold: this.threshold && this.threshold.getValue(dc.state),
                strictFilters: this.strictFilters && this.strictFilters.getValue(dc.state),
                top: this.top && this.top.getValue(dc.state),
                qnaId: 0,
                rankerType: this.rankerType && this.rankerType.getValue(dc.state),
                isTest: this.isTest,
                strictFiltersJoinOperator: this.strictFiltersJoinOperator,
            };
        });
    }
    /**
     * Gets the options the dialog will use to display query results to the user.
     * @param dc The dialog context for the current turn of conversation.
     * @remarks If the task is successful, the result contains the response options to use.
     * @returns A new instance of QnAMakerDialogResponseOptions.
     */
    getQnAResponseOptions(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                activeLearningCardTitle: this.activeLearningCardTitle && this.activeLearningCardTitle.getValue(dc.state),
                cardNoMatchResponse: this.cardNoMatchResponse && (yield this.cardNoMatchResponse.bind(dc, dc.state)),
                cardNoMatchText: this.cardNoMatchText && this.cardNoMatchText.getValue(dc.state),
                noAnswer: this.noAnswer && (yield this.noAnswer.bind(dc, dc.state)),
            };
        });
    }
    /**
     * Queries the knowledgebase and either passes result to the next step or constructs and displays an active learning card
     * if active learning is enabled and multiple score close answers are returned.
     **/
    callGenerateAnswer(step) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            dialogOptions.qnaMakerOptions.qnaId = 0;
            dialogOptions.qnaMakerOptions.context = { previousQnAId: 0, previousUserQuery: '' };
            step.values[this.currentQuery] = step.context.activity.text;
            const previousContextData = step.activeDialog.state[this.qnAContextData] || {};
            let previousQnAId = step.activeDialog.state[this.previousQnAId] || 0;
            if (previousQnAId > 0) {
                dialogOptions.qnaMakerOptions.context = { previousQnAId: previousQnAId, previousUserQuery: '' };
                if (previousContextData[step.context.activity.text]) {
                    dialogOptions.qnaMakerOptions.qnaId = previousContextData[step.context.activity.text];
                }
            }
            const qna = yield this.getQnAClient(step);
            const response = yield qna.getAnswersRaw(step.context, dialogOptions.qnaMakerOptions);
            const qnaResponse = {
                activeLearningEnabled: response.activeLearningEnabled,
                answers: response.answers,
            };
            previousQnAId = -1;
            step.activeDialog.state[this.previousQnAId] = previousQnAId;
            const isActiveLearningEnabled = qnaResponse.activeLearningEnabled;
            step.values[this.qnAData] = response.answers;
            if (qnaResponse.answers.length > 0 &&
                qnaResponse.answers[0].score <= activeLearningUtils_1.ActiveLearningUtils.MaximumScoreForLowScoreVariation / 100) {
                qnaResponse.answers = qna.getLowScoreVariation(qnaResponse.answers);
                if (isActiveLearningEnabled && qnaResponse.answers && qnaResponse.answers.length > 1) {
                    const suggestedQuestions = [];
                    qnaResponse.answers.forEach((answer) => {
                        suggestedQuestions.push(answer.questions[0]);
                    });
                    const message = qnaCardBuilder_1.QnACardBuilder.getSuggestionsCard(suggestedQuestions, dialogOptions.qnaDialogResponseOptions.activeLearningCardTitle, dialogOptions.qnaDialogResponseOptions.cardNoMatchText);
                    yield step.context.sendActivity(message);
                    step.activeDialog.state[this.options] = dialogOptions;
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            const result = [];
            if (response.answers && response.answers.length > 0) {
                result.push(response.answers[0]);
            }
            step.values[this.qnAData] = result;
            step.activeDialog.state[this.options] = dialogOptions;
            return yield step.next(result);
        });
    }
    /**
     * If active learning options were displayed in the previous step and the user has selected an option other
     * than 'no match' then the training API is called, passing the user's chosen question back to the knowledgebase.
     * If no active learning options were displayed in the previous step, the incoming result is immediately passed to the next step.
     **/
    callTrain(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const trainResponses = step.values[this.qnAData];
            const currentQuery = step.values[this.currentQuery];
            const reply = step.context.activity.text;
            if (trainResponses && trainResponses.length > 1) {
                const qnaResult = trainResponses.filter((r) => r.questions[0] == reply);
                if (qnaResult && qnaResult.length > 0) {
                    const results = [];
                    results.push(qnaResult[0]);
                    step.values[this.qnAData] = results;
                    const records = [];
                    records.push({
                        userId: step.context.activity.id,
                        userQuestion: currentQuery,
                        qnaId: qnaResult[0].id.toString(),
                    });
                    const feedbackRecords = { feedbackRecords: records };
                    const qnaClient = yield this.getQnAClient(step);
                    yield qnaClient.callTrainAsync(feedbackRecords);
                    return yield step.next(qnaResult);
                }
                else if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                    const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                    yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                    return step.endDialog();
                }
                else {
                    return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
                }
            }
            return yield step.next(step.result);
        });
    }
    /**
     * If multi turn prompts are included with the answer returned from the knowledgebase, this step constructs
     * and sends an activity with a hero card displaying the answer and the multi turn prompt options.
     * If no multi turn prompts exist then the result incoming result is passed to the next step.
     **/
    checkForMultiTurnPrompt(step) {
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const response = step.result;
            if (response && response.length > 0) {
                const answer = response[0];
                if (answer.context && answer.context.prompts.length > 0) {
                    const previousContextData = {};
                    answer.context.prompts.forEach((prompt) => {
                        previousContextData[prompt.displayText] = prompt.qnaId;
                    });
                    step.activeDialog.state[this.qnAContextData] = previousContextData;
                    step.activeDialog.state[this.previousQnAId] = answer.id;
                    step.activeDialog.state[this.options] = dialogOptions;
                    const message = qnaCardBuilder_1.QnACardBuilder.getQnAPromptsCard(answer);
                    yield step.context.sendActivity(message);
                    return botbuilder_dialogs_1.Dialog.EndOfTurn;
                }
            }
            return step.next(step.result);
        });
    }
    /**
     * Displays an appropriate response based on the incoming result to the user.If an answer has been identified it
     * is sent to the user. Alternatively, if no answer has been identified or the user has indicated 'no match' on an
     * active learning card, then an appropriate message is sent to the user.
     **/
    displayQnAResult(step) {
        const _super = Object.create(null, {
            runStep: { get: () => super.runStep }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const dialogOptions = step.activeDialog.state[this.options];
            const reply = step.context.activity.text;
            if (reply == dialogOptions.qnaDialogResponseOptions.cardNoMatchText) {
                const activity = dialogOptions.qnaDialogResponseOptions.cardNoMatchResponse;
                yield step.context.sendActivity(activity || this.defaultCardNoMatchResponse);
                return step.endDialog();
            }
            const previousQnaId = step.activeDialog.state[this.previousQnAId];
            if (previousQnaId > 0) {
                return yield _super.runStep.call(this, step, 0, botbuilder_dialogs_1.DialogReason.beginCalled);
            }
            const response = step.result;
            if (response && response.length > 0) {
                yield step.context.sendActivity(response[0].answer);
            }
            else {
                const activity = dialogOptions.qnaDialogResponseOptions.noAnswer;
                yield step.context.sendActivity(activity || this.defaultNoAnswer);
            }
            return yield step.endDialog(step.result);
        });
    }
    /**
     * Creates and returns an instance of the QnAMaker class used to query the knowledgebase.
     **/
    getQnAClient(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = {
                knowledgeBaseId: this.knowledgeBaseId.getValue(dc.state),
                endpointKey: this.endpointKey.getValue(dc.state),
                host: this.getHost(dc),
            };
            const logPersonalInformation = this.logPersonalInformation instanceof adaptive_expressions_1.BoolExpression
                ? this.logPersonalInformation.getValue(dc.state)
                : this.logPersonalInformation;
            return new _1.QnAMaker(endpoint, yield this.getQnAMakerOptions(dc), this.telemetryClient, logPersonalInformation);
        });
    }
    /**
     * Gets unmodified v5 API hostName or constructs v4 API hostName
     * @remarks
     * Example of a complete v5 API endpoint: "https://qnamaker-acom.azure.com/qnamaker/v5.0"
     * Template literal to construct v4 API endpoint: `https://${ this.hostName }.azurewebsites.net/qnamaker`
     */
    getHost(dc) {
        let host = this.hostname.getValue(dc.state);
        // If hostName includes 'qnamaker/v5', return the v5 API hostName.
        if (host.includes('qnamaker/v5')) {
            return host;
        }
        // V4 API logic
        // If the hostname contains all the necessary information, return it
        if (/^https:\/\/.*\.azurewebsites\.net\/qnamaker\/?/i.test(host)) {
            return host;
        }
        // Otherwise add required components
        if (!/https?:\/\//i.test(host)) {
            host = 'https://' + host;
        }
        // Web App Bots provisioned through the QnAMaker portal have "xxx.azurewebsites.net" in their
        // environment variables
        if (host.endsWith('.azurewebsites.net')) {
            // Add the remaining required path
            return host + '/qnamaker';
        }
        // If this.hostName is just the azurewebsite subdomain, finish the remaining V4 API behavior shipped in 4.8.0
        // e.g. `https://${ this.hostName }.azurewebsites.net/qnamaker`
        if (!host.endsWith('.azurewebsites.net/qnamaker')) {
            host = host + '.azurewebsites.net/qnamaker';
        }
        return host;
    }
}
QnAMakerDialog.$kind = 'Microsoft.QnAMakerDialog';
exports.QnAMakerDialog = QnAMakerDialog;
//# sourceMappingURL=qnaMakerDialog.js.map