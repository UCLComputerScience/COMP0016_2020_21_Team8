"use strict";
/**
 * @module botbuilder
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const botframework_connector_1 = require("botframework-connector");
const channelServiceHandler_1 = require("../channelServiceHandler");
const botFrameworkAdapter_1 = require("../botFrameworkAdapter");
/**
 * Casts adapter to BotFrameworkAdapter only if necessary
 * @param adapter adapter to maybe cast as BotFrameworkAdapter
 */
function maybeCastAdapter(adapter) {
    return adapter instanceof botFrameworkAdapter_1.BotFrameworkAdapter ? adapter : adapter;
}
/**
 * A Bot Framework Handler for skills.
 */
class SkillHandler extends channelServiceHandler_1.ChannelServiceHandler {
    /**
     * Initializes a new instance of the SkillHandler class.
     * @param adapter An instance of the BotAdapter that will handle the request.
     * @param bot The ActivityHandlerBase instance.
     * @param conversationIdFactory A SkillConversationIdFactoryBase to unpack the conversation ID and map it to the calling bot.
     * @param credentialProvider The credential provider.
     * @param authConfig The authentication configuration.
     * @param channelService The string indicating if the bot is working in Public Azure or in Azure Government (https://aka.ms/AzureGovDocs).
     */
    constructor(adapter, bot, conversationIdFactory, credentialProvider, authConfig, channelService) {
        super(credentialProvider, authConfig, channelService);
        this.adapter = adapter;
        this.bot = bot;
        this.conversationIdFactory = conversationIdFactory;
        /**
         * Used to access the CovnersationReference sent from the Skill to the Parent.
         * @remarks
         * The value is the same as the SkillConversationReferenceKey exported from botbuilder-core.
         */
        this.SkillConversationReferenceKey = botbuilder_core_1.SkillConversationReferenceKey;
        if (!adapter) {
            throw new Error('missing adapter.');
        }
        if (!bot) {
            throw new Error('missing bot.');
        }
        if (!conversationIdFactory) {
            throw new Error('missing conversationIdFactory.');
        }
    }
    /**
     * sendToConversation() API for Skill.
     * @remarks
     * This method allows you to send an activity to the end of a conversation.
     *
     * This is slightly different from replyToActivity().
     * * sendToConversation(conversationId) - will append the activity to the end
     * of the conversation according to the timestamp or semantics of the channel.
     * * replyToActivity(conversationId,ActivityId) - adds the activity as a reply
     * to another activity, if the channel supports it. If the channel does not
     * support nested replies, replyToActivity falls back to sendToConversation.
     *
     * Use replyToActivity when replying to a specific activity in the conversation.
     *
     * Use sendToConversation in all other cases.
     * @param claimsIdentity ClaimsIdentity for the bot, should have AudienceClaim, AppIdClaim and ServiceUrlClaim.
     * @param conversationId Conversation ID.
     * @param activity Activity to send.
     * @returns A Promise with a ResourceResponse.
     */
    onSendToConversation(claimsIdentity, conversationId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.processActivity(claimsIdentity, conversationId, null, activity);
        });
    }
    /**
     * replyToActivity() API for Skill.
     * @remarks
     * This method allows you to reply to an activity.
     *
     * This is slightly different from sendToConversation().
     * * sendToConversation(conversationId) - will append the activity to the end
     * of the conversation according to the timestamp or semantics of the channel.
     * * replyToActivity(conversationId,ActivityId) - adds the activity as a reply
     * to another activity, if the channel supports it. If the channel does not
     * support nested replies, replyToActivity falls back to sendToConversation.
     *
     * Use replyToActivity when replying to a specific activity in the conversation.
     *
     * Use sendToConversation in all other cases.
     * @param claimsIdentity ClaimsIdentity for the bot, should have AudienceClaim, AppIdClaim and ServiceUrlClaim.
     * @param conversationId Conversation ID.
     * @param activityId activityId the reply is to.
     * @param activity Activity to send.
     * @returns A Promise with a ResourceResponse.
     */
    onReplyToActivity(claimsIdentity, conversationId, activityId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.processActivity(claimsIdentity, conversationId, activityId, activity);
        });
    }
    /**
     * @private
     */
    static applyEoCToTurnContextActivity(turnContext, endOfConversationActivity) {
        // transform the turnContext.activity to be an EndOfConversation Activity.
        turnContext.activity.type = endOfConversationActivity.type;
        turnContext.activity.text = endOfConversationActivity.text;
        turnContext.activity.code = endOfConversationActivity.code;
        turnContext.activity.replyToId = endOfConversationActivity.replyToId;
        turnContext.activity.value = endOfConversationActivity.value;
        turnContext.activity.entities = endOfConversationActivity.entities;
        turnContext.activity.locale = endOfConversationActivity.locale;
        turnContext.activity.localTimestamp = endOfConversationActivity.localTimestamp;
        turnContext.activity.timestamp = endOfConversationActivity.timestamp;
        turnContext.activity.channelData = endOfConversationActivity.channelData;
    }
    /**
     * @private
     */
    static applyEventToTurnContextActivity(turnContext, eventActivity) {
        // transform the turnContext.activity to be an Event Activity.
        turnContext.activity.type = eventActivity.type;
        turnContext.activity.name = eventActivity.name;
        turnContext.activity.value = eventActivity.value;
        turnContext.activity.relatesTo = eventActivity.relatesTo;
        turnContext.activity.replyToId = eventActivity.replyToId;
        turnContext.activity.value = eventActivity.value;
        turnContext.activity.entities = eventActivity.entities;
        turnContext.activity.locale = eventActivity.locale;
        turnContext.activity.localTimestamp = eventActivity.localTimestamp;
        turnContext.activity.timestamp = eventActivity.timestamp;
        turnContext.activity.channelData = eventActivity.channelData;
    }
    /**
     * @private
     */
    getSkillConversationReference(conversationId) {
        return __awaiter(this, void 0, void 0, function* () {
            let skillConversationReference;
            try {
                skillConversationReference = yield this.conversationIdFactory.getSkillConversationReference(conversationId);
            }
            catch (err) {
                // If the factory has overridden getSkillConversationReference, call the deprecated getConversationReference().
                // In this scenario, the oAuthScope paired with the ConversationReference can only be used for talking with
                // an official channel, not another bot.
                if (err.message === 'Not Implemented') {
                    const conversationReference = yield this.conversationIdFactory.getConversationReference(conversationId);
                    skillConversationReference = {
                        conversationReference,
                        oAuthScope: botframework_connector_1.JwtTokenValidation.isGovernment(this.channelService)
                            ? botframework_connector_1.GovernmentConstants.ToChannelFromBotOAuthScope
                            : botframework_connector_1.AuthenticationConstants.ToChannelFromBotOAuthScope,
                    };
                }
                else {
                    // Re-throw all other errors.
                    throw err;
                }
            }
            if (!skillConversationReference) {
                throw new Error('skillConversationReference not found');
            }
            else if (!skillConversationReference.conversationReference) {
                throw new Error('conversationReference not found.');
            }
            return skillConversationReference;
        });
    }
    /**
     * Helper method for forwarding a conversation through the adapter
     */
    continueConversation(claimsIdentity, conversationId, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const ref = yield this.getSkillConversationReference(conversationId);
            // Add the channel service URL to the trusted services list so we can send messages back.
            // the service URL for skills is trusted because it is applied based on the original request
            // received by the root bot.
            botframework_connector_1.AppCredentials.trustServiceUrl(ref.conversationReference.serviceUrl);
            return maybeCastAdapter(this.adapter).continueConversation(ref.conversationReference, ref.oAuthScope, (context) => __awaiter(this, void 0, void 0, function* () {
                const adapter = maybeCastAdapter(context.adapter);
                // Cache the claimsIdentity and conversation reference
                context.turnState.set(adapter.BotIdentityKey, claimsIdentity);
                context.turnState.set(this.SkillConversationReferenceKey, ref);
                return callback(adapter, ref, context);
            }));
        });
    }
    processActivity(claimsIdentity, conversationId, activityId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            // If an activity is sent, return the ResourceResponse
            let resourceResponse;
            /**
             * This callback does the following:
             *  - Applies the correct ConversationReference to the Activity for sending to the user-router conversation.
             *  - For EndOfConversation Activities received from the Skill, removes the ConversationReference from the
             *    ConversationIdFactory
             */
            yield this.continueConversation(claimsIdentity, conversationId, (adapter, ref, context) => __awaiter(this, void 0, void 0, function* () {
                const newActivity = botbuilder_core_1.TurnContext.applyConversationReference(activity, ref.conversationReference);
                context.activity.id = activityId;
                context.activity.callerId = `${botbuilder_core_1.CallerIdConstants.BotToBotPrefix}${botframework_connector_1.JwtTokenValidation.getAppIdFromClaims(claimsIdentity.claims)}`;
                // Cache connector client in turn context
                const client = adapter.createConnectorClient(newActivity.serviceUrl);
                context.turnState.set(adapter.ConnectorClientKey, client);
                switch (newActivity.type) {
                    case botbuilder_core_1.ActivityTypes.EndOfConversation:
                        yield this.conversationIdFactory.deleteConversationReference(conversationId);
                        SkillHandler.applyEoCToTurnContextActivity(context, newActivity);
                        yield this.bot.run(context);
                        break;
                    case botbuilder_core_1.ActivityTypes.Event:
                        SkillHandler.applyEventToTurnContextActivity(context, newActivity);
                        yield this.bot.run(context);
                        break;
                    default:
                        resourceResponse = yield context.sendActivity(newActivity);
                        break;
                }
            }));
            if (!resourceResponse) {
                resourceResponse = { id: uuid() };
            }
            return resourceResponse;
        });
    }
    /**
     *
     * UpdateActivity() API for Skill.
     * @remarks
     * Edit an existing activity.
     *
     * Some channels allow you to edit an existing activity to reflect the new
     * state of a bot conversation.
     *
     * For example, you can remove buttons after someone has clicked "Approve" button.
     * @param claimsIdentity ClaimsIdentity for the bot, should have AudienceClaim, AppIdClaim and ServiceUrlClaim.
     * @param conversationId Conversation ID.
     * @param activityId activityId to update.
     * @param activity replacement Activity.
     */
    onUpdateActivity(claimsIdentity, conversationId, activityId, activity) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.continueConversation(claimsIdentity, conversationId, (adapter, ref, context) => __awaiter(this, void 0, void 0, function* () {
                const newActivity = botbuilder_core_1.TurnContext.applyConversationReference(activity, ref.conversationReference);
                context.activity.id = activityId;
                context.activity.callerId = `${botbuilder_core_1.CallerIdConstants.BotToBotPrefix}${botframework_connector_1.JwtTokenValidation.getAppIdFromClaims(claimsIdentity.claims)}`;
                return context.updateActivity(newActivity);
            }));
            // Note: the original activity ID is passed back here to provide "behavioral" parity with the C# SDK. Due to
            // some inconsistent method signatures, the proper response is not propagated back through `context.updateActivity`
            // so we have to manually pass this value back.
            return { id: activityId };
        });
    }
    /**
     * DeleteActivity() API for Skill.
     * @remarks
     * Delete an existing activity.
     *
     * Some channels allow you to delete an existing activity, and if successful
     * this method will remove the specified activity.
     *
     *
     * @param claimsIdentity ClaimsIdentity for the bot, should have AudienceClaim, AppIdClaim and ServiceUrlClaim.
     * @param conversationId Conversation ID.
     * @param activityId activityId to delete.
     */
    onDeleteActivity(claimsIdentity, conversationId, activityId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Callback method handles deleting activity
            return this.continueConversation(claimsIdentity, conversationId, (adapter, ref, context) => __awaiter(this, void 0, void 0, function* () {
                return context.deleteActivity(activityId);
            }));
        });
    }
}
exports.SkillHandler = SkillHandler;
// Helper function to generate an UUID.
// Code is from @stevenic: https://github.com/stevenic
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
//# sourceMappingURL=skillHandler.js.map