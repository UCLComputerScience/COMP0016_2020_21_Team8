"use strict";
/**
 * @module botbuilder-ai
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const botbuilder_core_1 = require("botbuilder-core");
const qnamaker_interfaces_1 = require("./qnamaker-interfaces");
const qnamaker_utils_1 = require("./qnamaker-utils");
const qnaTelemetryConstants_1 = require("./qnaTelemetryConstants");
exports.QNAMAKER_TRACE_TYPE = 'https://www.qnamaker.ai/schemas/trace';
exports.QNAMAKER_TRACE_NAME = 'QnAMaker';
exports.QNAMAKER_TRACE_LABEL = 'QnAMaker Trace';
/**
 * Query a QnA Maker knowledge base for answers and provide feedbacks.
 *
 * @remarks
 * This class is used to make queries to a single QnA Maker knowledge base and return the result.
 *
 * Use this to process incoming messages with the [getAnswers()](#getAnswers) method.
 */
class QnAMaker {
    /**
     * Creates a new QnAMaker instance.
     * @param endpoint The endpoint of the knowledge base to query.
     * @param options (Optional) additional settings used to configure the instance.
     * @param telemetryClient The BotTelemetryClient used for logging telemetry events.
     * @param logPersonalInformation Set to true to include personally indentifiable information in telemetry events.
     */
    constructor(endpoint, options = {}, telemetryClient, logPersonalInformation) {
        this.endpoint = endpoint;
        if (!endpoint) {
            throw new TypeError('QnAMaker requires valid QnAMakerEndpoint.');
        }
        const { scoreThreshold = 0.3, top = 1, strictFilters = [], metadataBoost = [], timeout = 100000, rankerType = qnamaker_interfaces_1.RankerTypes.default, strictFiltersJoinOperator = qnamaker_interfaces_1.JoinOperator.AND, } = options;
        this._options = {
            scoreThreshold,
            top,
            strictFilters,
            metadataBoost,
            timeout,
            rankerType,
            strictFiltersJoinOperator,
        };
        this.generateAnswerUtils = new qnamaker_utils_1.GenerateAnswerUtils(this._options, this.endpoint);
        this.trainUtils = new qnamaker_utils_1.TrainUtils(this.endpoint);
        this._telemetryClient = telemetryClient || new botbuilder_core_1.NullTelemetryClient();
        this._logPersonalInformation = logPersonalInformation || false;
    }
    /**
     * Gets a value indicating whether determines whether to log personal information that came from the user.
     */
    get logPersonalInformation() {
        return this._logPersonalInformation;
    }
    /**
     * Gets the currently configured botTelemetryClient that logs the events.
     */
    get telemetryClient() {
        return this._telemetryClient;
    }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * In addition to returning the results from QnA Maker, [getAnswers()](#getAnswers) will also
     * emit a trace activity that contains the QnA Maker results.
     *
     * @param context The Turn Context that contains the user question to be queried against your knowledge base.
     * @param options (Optional) The options for the QnA Maker knowledge base. If null, constructor option is used for this instance.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     */
    getAnswers(context, options, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new TypeError('QnAMaker.getAnswers() requires a TurnContext.');
            }
            const response = yield this.getAnswersRaw(context, options, telemetryProperties, telemetryMetrics);
            if (!response) {
                return [];
            }
            return response.answers;
        });
    }
    /**
     * Generates an answer from the knowledge base.
     * @param context The [TurnContext](xref:botbuilder-core.TurnContext) that contains the user question to be queried against your knowledge base.
     * @param options Optional. The [QnAMakerOptions](xref:botbuilder-ai.QnAMakerOptions) for the QnA Maker knowledge base. If null, constructor option is used for this instance.
     * @param telemetryProperties Optional. Additional properties to be logged to telemetry with the QnaMessage event.
     * @param telemetryMetrics Optional. Additional metrics to be logged to telemetry with the QnaMessage event.
     * @returns A list of answers for the user query, sorted in decreasing order of ranking score.
     */
    getAnswersRaw(context, options, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new TypeError('QnAMaker.getAnswers() requires a TurnContext.');
            }
            const queryResult = [];
            const question = this.getTrimmedMessageText(context);
            const queryOptions = Object.assign({}, this._options, options);
            this.generateAnswerUtils.validateOptions(queryOptions);
            let result;
            if (question.length > 0) {
                result = yield this.generateAnswerUtils.queryQnaServiceRaw(this.endpoint, question, queryOptions);
                const sortedQnaAnswers = qnamaker_utils_1.GenerateAnswerUtils.sortAnswersWithinThreshold(result.answers, queryOptions);
                queryResult.push(...sortedQnaAnswers);
            }
            if (!result) {
                return result;
            }
            yield Promise.all([
                // Log telemetry
                this.onQnaResults(queryResult, context, telemetryProperties, telemetryMetrics),
                this.generateAnswerUtils.emitTraceInfo(context, queryResult, queryOptions)
            ]);
            const qnaResponse = {
                activeLearningEnabled: result.activeLearningEnabled,
                answers: queryResult,
            };
            return qnaResponse;
        });
    }
    /**
     * Calls [generateAnswer()](#generateanswer) and sends the resulting answer as a reply to the user.
     * @deprecated Instead, favor using [QnAMaker.getAnswers()](#getAnswers) to generate answers for a question.
     *
     * @remarks
     * Returns a value of `true` if an answer was found and sent. If multiple answers are
     * returned the first one will be delivered.
     * @param context Context for the current turn of conversation with the user.
     */
    answer(context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!context) {
                throw new TypeError('QnAMaker.answer() requires a TurnContext.');
            }
            const { top, scoreThreshold } = this._options;
            const question = this.getTrimmedMessageText(context);
            const answers = yield this.generateAnswer(question, top, scoreThreshold);
            yield this.generateAnswerUtils.emitTraceInfo(context, answers, this._options);
            if (answers.length > 0) {
                yield context.sendActivity({ text: answers[0].answer, type: 'message' });
                return true;
            }
            return false;
        });
    }
    /**
     * Calls the QnA Maker service to generate answer(s) for a question.
     *
     * @deprecated Instead, favor using [QnAMaker.getAnswers()](#getAnswers) to generate answers for a question.
     *
     * @remarks
     * Returns an array of answers sorted by score with the top scoring answer returned first.
     *
     * @param question The question to answer.
     * @param top (Optional) number of answers to return. Defaults to a value of `1`.
     * @param scoreThreshold (Optional) minimum answer score needed to be considered a match to questions. Defaults to a value of `0.001`.
     */
    generateAnswer(question, top, scoreThreshold) {
        return __awaiter(this, void 0, void 0, function* () {
            const trimmedAnswer = question ? question.trim() : '';
            if (trimmedAnswer.length > 0) {
                const result = yield this.callService(this.endpoint, question, typeof top === 'number' ? top : 1);
                const minScore = typeof scoreThreshold === 'number' ? scoreThreshold : 0.001;
                return result.answers
                    .filter((ans) => ans.score >= minScore)
                    .sort((a, b) => b.score - a.score);
            }
            return [];
        });
    }
    /**
     * Filters the ambiguous question for active learning.
     *
     * @remarks
     * Returns a filtered array of ambiguous question.
     *
     * @param queryResult User query output.
     */
    getLowScoreVariation(queryResult) {
        return qnamaker_utils_1.ActiveLearningUtils.getLowScoreVariation(queryResult);
    }
    /**
     * Send feedback to the knowledge base.
     *
     * @param feedbackRecords Feedback records.
     */
    callTrainAsync(feedbackRecords) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.trainUtils.callTrain(feedbackRecords);
        });
    }
    /**
     * Called internally to query the QnA Maker service.
     *
     * @remarks
     * This is exposed to enable better unit testing of the service.
     */
    callService(endpoint, question, top) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.generateAnswerUtils.queryQnaServiceRaw(endpoint, question, { top });
        });
    }
    /**
     * Invoked prior to a QnaMessage Event being logged.
     * @param qnaResult The QnA Results for the call.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @param telemetryMetrics Additional metrics to be logged to telemetry with the QnaMessage event.
     */
    onQnaResults(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            this.fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics).then((data) => {
                this.telemetryClient.trackEvent({
                    name: qnaTelemetryConstants_1.QnATelemetryConstants.qnaMessageEvent,
                    properties: data[0],
                    metrics: data[1],
                });
            });
            return;
        });
    }
    /**
     * Fills the event properties for QnaMessage event for telemetry.
     * These properties are logged when the recognizer is called.
     * @param qnaResult Last activity sent from user.
     * @param turnContext Context object containing information for a single turn of conversation with a user.
     * @param telemetryProperties Additional properties to be logged to telemetry with the QnaMessage event.
     * @returns A dictionary that is sent as properties to BotTelemetryClient.trackEvent method for the QnaMessage event.
     */
    fillQnAEvent(qnaResults, turnContext, telemetryProperties, telemetryMetrics) {
        return __awaiter(this, void 0, void 0, function* () {
            let properties = {};
            let metrics = {};
            properties[qnaTelemetryConstants_1.QnATelemetryConstants.knowledgeBaseIdProperty] = this.endpoint.knowledgeBaseId;
            const text = turnContext.activity.text;
            const userName = 'from' in turnContext.activity ? turnContext.activity.from.name : '';
            // Use the LogPersonalInformation flag to toggle logging PII data, text is a common example
            if (this.logPersonalInformation) {
                if (text) {
                    properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionProperty] = text;
                }
                if (userName) {
                    properties[qnaTelemetryConstants_1.QnATelemetryConstants.usernameProperty] = userName;
                }
            }
            // Fill in Qna Results (found or not)
            if (qnaResults.length > 0) {
                const queryResult = qnaResults[0];
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.matchedQuestionProperty] = JSON.stringify(queryResult.questions);
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionIdProperty] = String(queryResult.id);
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.answerProperty] = queryResult.answer;
                metrics[qnaTelemetryConstants_1.QnATelemetryConstants.scoreMetric] = queryResult.score;
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.articleFoundProperty] = 'true';
            }
            else {
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.matchedQuestionProperty] = 'No Qna Question matched';
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.questionIdProperty] = 'No Qna Question Id matched';
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.answerProperty] = 'No Qna Answer matched';
                properties[qnaTelemetryConstants_1.QnATelemetryConstants.articleFoundProperty] = 'false';
            }
            // Additional Properties can override "stock" properties.
            if (telemetryProperties != null) {
                properties = Object.assign({}, properties, telemetryProperties);
            }
            // Additional Metrics can override "stock" metrics.
            if (telemetryMetrics != null) {
                metrics = Object.assign({}, metrics, telemetryMetrics);
            }
            return [properties, metrics];
        });
    }
    /**
     * Gets the message from the Activity in the TurnContext, trimmed of whitespaces.
     */
    getTrimmedMessageText(context) {
        const question = context && context.activity && context.activity.text ? context.activity.text : '';
        return question.trim();
    }
}
exports.QnAMaker = QnAMaker;
//# sourceMappingURL=qnaMaker.js.map